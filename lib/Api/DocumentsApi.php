<?php
/**
 * DocumentsApi
 * PHP version 5
 *
 * @category Class
 * @package  Lacuna\Signer
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Dropsigner
 *
 * <!--------------------------------------------------------------------------------------------------------------------->    <h2>Authentication</h2>    <p>   In order to call this APIs, you will need an <strong>API key</strong>. Set the API key in the header <span class=\"code\">X-Api-Key</span>:  </p>    <pre>X-Api-Key: your-app|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</pre>    <!--------------------------------------------------------------------------------------------------------------------->  <br />    <h2>HTTP Codes</h2>    <p>   The APIs will return the following HTTP codes:  </p>    <table>   <thead>    <tr>     <th>Code</th>     <th>Description</th>    </tr>   </thead>   <tbody>    <tr>     <td><strong class=\"model-title\">200 (OK)</strong></td>     <td>Request processed successfully. The response is different for each API, please refer to the operation's documentation</td>    </tr>    <tr>     <td><strong class=\"model-title\">400 (Bad Request)</strong></td>     <td>Syntax error. For instance, when a required field was not provided</td>    </tr>    <tr>     <td><strong class=\"model-title\">401 (Unauthorized)</strong></td>     <td>API key not provided or invalid</td>    </tr>    <tr>     <td><strong class=\"model-title\">403 (Forbidden)</strong></td>     <td>API key is valid, but the application has insufficient permissions to complete the requested operation</td>    </tr>    <tr>     <td><strong class=\"model-title\">422 (Unprocessable Entity)</strong></td>     <td>API error. The response is as defined in <a href=\"#model-ErrorModel\">ErrorModel</a></td>    </tr>   </tbody>  </table>    <br />    <h3>Error Codes</h3>    <p>Some of the error codes returned in a 422 response are provided bellow*:</p>    <ul>   <li>CertificateNotFound</li>   <li>DocumentNotFound</li>   <li>FolderNotFound</li>   <li>CpfMismatch</li>   <li>CpfNotExpected</li>   <li>InvalidFlowAction</li>   <li>DocumentInvalidKey</li>  </ul>    <p style=\"font-size: 0.9em\">   *The codes shown above are the main error codes. Nonetheless, this list is not comprehensive. New codes may be added anytime without previous warning.  </p>    <!--------------------------------------------------------------------------------------------------------------------->    <br />    <h2>Webhooks</h2>    <p>   It is recomended to subscribe to Webhook events <strong>instead</strong> of polling APIs. To do so, enable webhooks and register an URL that will receive a POST request   whenever one of the events bellow occur.  </p>  <p>   All requests have the format described in <a href=\"#model-Webhooks.WebhookModel\">Webhooks.WebhookModel</a>.   The data field varies according to the webhook event type:  </p>      <table>   <thead>    <tr>     <th>Event type</th>     <th>Description</th>     <th>Payload</th>    </tr>   </thead>   <tbody>    <tr>     <td><strong class=\"model-title\">DocumentSigned</strong></td>     <td>Triggered when a document is signed.</td>     <td><a href=\"#model-Webhooks.DocumentSignedModel\">Webhooks.DocumentSignedModel</a></td>    </tr>    <tr>     <td><strong class=\"model-title\">DocumentApproved</strong></td>     <td>Triggered when a document is approved.</td>     <td><a href=\"#model-Webhooks.DocumentApprovedModel\">Webhooks.DocumentApprovedModel</a></td>    </tr>    <tr>     <td><strong class=\"model-title\">DocumentRefused</strong></td>     <td>Triggered when a document is refused.</td>     <td><a href=\"#model-Webhooks.DocumentRefusedModel\">Webhooks.DocumentRefusedModel</a></td>    </tr>    <tr>     <td><strong class=\"model-title\">DocumentConcluded</strong></td>     <td>Triggered when the flow of a document is concluded.</td>     <td><a href=\"#model-Webhooks.DocumentConcludedModel\">Webhooks.DocumentConcludedModel</a></td>    </tr>    <tr>     <td><strong class=\"model-title\">DocumentCanceled</strong></td>     <td>Triggered when the document is canceled.</td>     <td><a href=\"#model-Webhooks.DocumentCanceledModel\">Webhooks.DocumentCanceledModel</a></td>    </tr>    <tr>     <td><strong class=\"model-title\">DocumentsCreated (v1.50.0)</strong></td>     <td>Triggered when one or more documents are created.</td>     <td><a href=\"#model-Webhooks.DocumentsCreatedModel\">Webhooks.DocumentsCreatedModel</a></td>    </tr>   </tbody>  </table>    <p>   To register your application URL and enable Webhooks, access the integrations section in your <a href=\"/private/organizations\" target=\"_blank\">organization's details page</a>.  </p>
 *
 * OpenAPI spec version: 1.55.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.41
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Lacuna\Signer\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Lacuna\Signer\ApiException;
use Lacuna\Signer\Configuration;
use Lacuna\Signer\HeaderSelector;
use Lacuna\Signer\ObjectSerializer;

/**
 * DocumentsApi Class Doc Comment
 *
 * @category Class
 * @package  Lacuna\Signer
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DocumentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiDocumentsBatchFolderPost
     *
     * Moves a batch of documents to a folder.
     *
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentBatchRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\BatchItemResultModel[]
     */
    public function apiDocumentsBatchFolderPost($body = null)
    {
        list($response) = $this->apiDocumentsBatchFolderPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiDocumentsBatchFolderPostWithHttpInfo
     *
     * Moves a batch of documents to a folder.
     *
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentBatchRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\BatchItemResultModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsBatchFolderPostWithHttpInfo($body = null)
    {
        $returnType = '\Lacuna\Signer\Model\BatchItemResultModel[]';
        $request = $this->apiDocumentsBatchFolderPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\BatchItemResultModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsBatchFolderPostAsync
     *
     * Moves a batch of documents to a folder.
     *
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentBatchRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsBatchFolderPostAsync($body = null)
    {
        return $this->apiDocumentsBatchFolderPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsBatchFolderPostAsyncWithHttpInfo
     *
     * Moves a batch of documents to a folder.
     *
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentBatchRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsBatchFolderPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Lacuna\Signer\Model\BatchItemResultModel[]';
        $request = $this->apiDocumentsBatchFolderPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsBatchFolderPost'
     *
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentBatchRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsBatchFolderPostRequest($body = null)
    {

        $resourcePath = '/api/documents/batch/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsGet
     *
     * Retrieves the documents of the organization paginating the response.
     *
     * @param  bool $isConcluded (DEPRECATED) Please use \&quot;Status\&quot; parameter instead. Set to true to list concluded documents, false to list pending documents. (optional)
     * @param  \Lacuna\Signer\Model\DocumentFilterStatus $status Filters by document status. Will override the \&quot;IsConcluded\&quot; property. (optional)
     * @param  string $folderId folderId (optional)
     * @param  \Lacuna\Signer\Model\FolderType $folderType folderType (optional)
     * @param  \Lacuna\Signer\Model\DocumentTypes $documentType documentType (optional)
     * @param  bool $filterByDocumentType True if the documents should be filtered by type, use documentType to specify the document type.  If you want to filter only documents without a type, set this parameter to true and the documentType to null. (optional)
     * @param  bool $filterByPendingSignature True if documents should be filtered only for those that have FlowAction of the type Signer or SignRule (optional)
     * @param  \Lacuna\Signer\Model\DocumentQueryTypes $queryType queryType (optional)
     * @param  string $participantQ Query to filter by participant (optional)
     * @param  \Lacuna\Signer\Model\ParticipantQueryTypes $participantQueryType participantQueryType (optional)
     * @param  string $tags Label/value pairs are separated by \&quot;|\&quot; (optional) and Tags separated by \&quot;,\&quot;. Only the first 10 pairs will be considered.&lt;br /&gt;To search by tag value only, do not use the \&quot;|\&quot;. (optional)
     * @param  string $q Query to filter items. (optional)
     * @param  int $limit Number of items to return. (optional)
     * @param  int $offset The offset of the searched page (starting with 0). (optional)
     * @param  \Lacuna\Signer\Model\PaginationOrders $order order (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\PaginatedSearchResponseDocumentsDocumentListModel
     */
    public function apiDocumentsGet($isConcluded = null, $status = null, $folderId = null, $folderType = null, $documentType = null, $filterByDocumentType = null, $filterByPendingSignature = null, $queryType = null, $participantQ = null, $participantQueryType = null, $tags = null, $q = null, $limit = null, $offset = null, $order = null)
    {
        list($response) = $this->apiDocumentsGetWithHttpInfo($isConcluded, $status, $folderId, $folderType, $documentType, $filterByDocumentType, $filterByPendingSignature, $queryType, $participantQ, $participantQueryType, $tags, $q, $limit, $offset, $order);
        return $response;
    }

    /**
     * Operation apiDocumentsGetWithHttpInfo
     *
     * Retrieves the documents of the organization paginating the response.
     *
     * @param  bool $isConcluded (DEPRECATED) Please use \&quot;Status\&quot; parameter instead. Set to true to list concluded documents, false to list pending documents. (optional)
     * @param  \Lacuna\Signer\Model\DocumentFilterStatus $status Filters by document status. Will override the \&quot;IsConcluded\&quot; property. (optional)
     * @param  string $folderId (optional)
     * @param  \Lacuna\Signer\Model\FolderType $folderType (optional)
     * @param  \Lacuna\Signer\Model\DocumentTypes $documentType (optional)
     * @param  bool $filterByDocumentType True if the documents should be filtered by type, use documentType to specify the document type.  If you want to filter only documents without a type, set this parameter to true and the documentType to null. (optional)
     * @param  bool $filterByPendingSignature True if documents should be filtered only for those that have FlowAction of the type Signer or SignRule (optional)
     * @param  \Lacuna\Signer\Model\DocumentQueryTypes $queryType (optional)
     * @param  string $participantQ Query to filter by participant (optional)
     * @param  \Lacuna\Signer\Model\ParticipantQueryTypes $participantQueryType (optional)
     * @param  string $tags Label/value pairs are separated by \&quot;|\&quot; (optional) and Tags separated by \&quot;,\&quot;. Only the first 10 pairs will be considered.&lt;br /&gt;To search by tag value only, do not use the \&quot;|\&quot;. (optional)
     * @param  string $q Query to filter items. (optional)
     * @param  int $limit Number of items to return. (optional)
     * @param  int $offset The offset of the searched page (starting with 0). (optional)
     * @param  \Lacuna\Signer\Model\PaginationOrders $order (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\PaginatedSearchResponseDocumentsDocumentListModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsGetWithHttpInfo($isConcluded = null, $status = null, $folderId = null, $folderType = null, $documentType = null, $filterByDocumentType = null, $filterByPendingSignature = null, $queryType = null, $participantQ = null, $participantQueryType = null, $tags = null, $q = null, $limit = null, $offset = null, $order = null)
    {
        $returnType = '\Lacuna\Signer\Model\PaginatedSearchResponseDocumentsDocumentListModel';
        $request = $this->apiDocumentsGetRequest($isConcluded, $status, $folderId, $folderType, $documentType, $filterByDocumentType, $filterByPendingSignature, $queryType, $participantQ, $participantQueryType, $tags, $q, $limit, $offset, $order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\PaginatedSearchResponseDocumentsDocumentListModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsGetAsync
     *
     * Retrieves the documents of the organization paginating the response.
     *
     * @param  bool $isConcluded (DEPRECATED) Please use \&quot;Status\&quot; parameter instead. Set to true to list concluded documents, false to list pending documents. (optional)
     * @param  \Lacuna\Signer\Model\DocumentFilterStatus $status Filters by document status. Will override the \&quot;IsConcluded\&quot; property. (optional)
     * @param  string $folderId (optional)
     * @param  \Lacuna\Signer\Model\FolderType $folderType (optional)
     * @param  \Lacuna\Signer\Model\DocumentTypes $documentType (optional)
     * @param  bool $filterByDocumentType True if the documents should be filtered by type, use documentType to specify the document type.  If you want to filter only documents without a type, set this parameter to true and the documentType to null. (optional)
     * @param  bool $filterByPendingSignature True if documents should be filtered only for those that have FlowAction of the type Signer or SignRule (optional)
     * @param  \Lacuna\Signer\Model\DocumentQueryTypes $queryType (optional)
     * @param  string $participantQ Query to filter by participant (optional)
     * @param  \Lacuna\Signer\Model\ParticipantQueryTypes $participantQueryType (optional)
     * @param  string $tags Label/value pairs are separated by \&quot;|\&quot; (optional) and Tags separated by \&quot;,\&quot;. Only the first 10 pairs will be considered.&lt;br /&gt;To search by tag value only, do not use the \&quot;|\&quot;. (optional)
     * @param  string $q Query to filter items. (optional)
     * @param  int $limit Number of items to return. (optional)
     * @param  int $offset The offset of the searched page (starting with 0). (optional)
     * @param  \Lacuna\Signer\Model\PaginationOrders $order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsGetAsync($isConcluded = null, $status = null, $folderId = null, $folderType = null, $documentType = null, $filterByDocumentType = null, $filterByPendingSignature = null, $queryType = null, $participantQ = null, $participantQueryType = null, $tags = null, $q = null, $limit = null, $offset = null, $order = null)
    {
        return $this->apiDocumentsGetAsyncWithHttpInfo($isConcluded, $status, $folderId, $folderType, $documentType, $filterByDocumentType, $filterByPendingSignature, $queryType, $participantQ, $participantQueryType, $tags, $q, $limit, $offset, $order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsGetAsyncWithHttpInfo
     *
     * Retrieves the documents of the organization paginating the response.
     *
     * @param  bool $isConcluded (DEPRECATED) Please use \&quot;Status\&quot; parameter instead. Set to true to list concluded documents, false to list pending documents. (optional)
     * @param  \Lacuna\Signer\Model\DocumentFilterStatus $status Filters by document status. Will override the \&quot;IsConcluded\&quot; property. (optional)
     * @param  string $folderId (optional)
     * @param  \Lacuna\Signer\Model\FolderType $folderType (optional)
     * @param  \Lacuna\Signer\Model\DocumentTypes $documentType (optional)
     * @param  bool $filterByDocumentType True if the documents should be filtered by type, use documentType to specify the document type.  If you want to filter only documents without a type, set this parameter to true and the documentType to null. (optional)
     * @param  bool $filterByPendingSignature True if documents should be filtered only for those that have FlowAction of the type Signer or SignRule (optional)
     * @param  \Lacuna\Signer\Model\DocumentQueryTypes $queryType (optional)
     * @param  string $participantQ Query to filter by participant (optional)
     * @param  \Lacuna\Signer\Model\ParticipantQueryTypes $participantQueryType (optional)
     * @param  string $tags Label/value pairs are separated by \&quot;|\&quot; (optional) and Tags separated by \&quot;,\&quot;. Only the first 10 pairs will be considered.&lt;br /&gt;To search by tag value only, do not use the \&quot;|\&quot;. (optional)
     * @param  string $q Query to filter items. (optional)
     * @param  int $limit Number of items to return. (optional)
     * @param  int $offset The offset of the searched page (starting with 0). (optional)
     * @param  \Lacuna\Signer\Model\PaginationOrders $order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsGetAsyncWithHttpInfo($isConcluded = null, $status = null, $folderId = null, $folderType = null, $documentType = null, $filterByDocumentType = null, $filterByPendingSignature = null, $queryType = null, $participantQ = null, $participantQueryType = null, $tags = null, $q = null, $limit = null, $offset = null, $order = null)
    {
        $returnType = '\Lacuna\Signer\Model\PaginatedSearchResponseDocumentsDocumentListModel';
        $request = $this->apiDocumentsGetRequest($isConcluded, $status, $folderId, $folderType, $documentType, $filterByDocumentType, $filterByPendingSignature, $queryType, $participantQ, $participantQueryType, $tags, $q, $limit, $offset, $order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsGet'
     *
     * @param  bool $isConcluded (DEPRECATED) Please use \&quot;Status\&quot; parameter instead. Set to true to list concluded documents, false to list pending documents. (optional)
     * @param  \Lacuna\Signer\Model\DocumentFilterStatus $status Filters by document status. Will override the \&quot;IsConcluded\&quot; property. (optional)
     * @param  string $folderId (optional)
     * @param  \Lacuna\Signer\Model\FolderType $folderType (optional)
     * @param  \Lacuna\Signer\Model\DocumentTypes $documentType (optional)
     * @param  bool $filterByDocumentType True if the documents should be filtered by type, use documentType to specify the document type.  If you want to filter only documents without a type, set this parameter to true and the documentType to null. (optional)
     * @param  bool $filterByPendingSignature True if documents should be filtered only for those that have FlowAction of the type Signer or SignRule (optional)
     * @param  \Lacuna\Signer\Model\DocumentQueryTypes $queryType (optional)
     * @param  string $participantQ Query to filter by participant (optional)
     * @param  \Lacuna\Signer\Model\ParticipantQueryTypes $participantQueryType (optional)
     * @param  string $tags Label/value pairs are separated by \&quot;|\&quot; (optional) and Tags separated by \&quot;,\&quot;. Only the first 10 pairs will be considered.&lt;br /&gt;To search by tag value only, do not use the \&quot;|\&quot;. (optional)
     * @param  string $q Query to filter items. (optional)
     * @param  int $limit Number of items to return. (optional)
     * @param  int $offset The offset of the searched page (starting with 0). (optional)
     * @param  \Lacuna\Signer\Model\PaginationOrders $order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsGetRequest($isConcluded = null, $status = null, $folderId = null, $folderType = null, $documentType = null, $filterByDocumentType = null, $filterByPendingSignature = null, $queryType = null, $participantQ = null, $participantQueryType = null, $tags = null, $q = null, $limit = null, $offset = null, $order = null)
    {

        $resourcePath = '/api/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($isConcluded !== null) {
            $queryParams['IsConcluded'] = ObjectSerializer::toQueryValue($isConcluded, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['Status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($folderId !== null) {
            $queryParams['FolderId'] = ObjectSerializer::toQueryValue($folderId, 'uuid');
        }
        // query params
        if ($folderType !== null) {
            $queryParams['FolderType'] = ObjectSerializer::toQueryValue($folderType, null);
        }
        // query params
        if ($documentType !== null) {
            $queryParams['DocumentType'] = ObjectSerializer::toQueryValue($documentType, null);
        }
        // query params
        if ($filterByDocumentType !== null) {
            $queryParams['FilterByDocumentType'] = ObjectSerializer::toQueryValue($filterByDocumentType, null);
        }
        // query params
        if ($filterByPendingSignature !== null) {
            $queryParams['FilterByPendingSignature'] = ObjectSerializer::toQueryValue($filterByPendingSignature, null);
        }
        // query params
        if ($queryType !== null) {
            $queryParams['QueryType'] = ObjectSerializer::toQueryValue($queryType, null);
        }
        // query params
        if ($participantQ !== null) {
            $queryParams['ParticipantQ'] = ObjectSerializer::toQueryValue($participantQ, null);
        }
        // query params
        if ($participantQueryType !== null) {
            $queryParams['ParticipantQueryType'] = ObjectSerializer::toQueryValue($participantQueryType, null);
        }
        // query params
        if ($tags !== null) {
            $queryParams['Tags'] = ObjectSerializer::toQueryValue($tags, null);
        }
        // query params
        if ($q !== null) {
            $queryParams['Q'] = ObjectSerializer::toQueryValue($q, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['Limit'] = ObjectSerializer::toQueryValue($limit, 'int32');
        }
        // query params
        if ($offset !== null) {
            $queryParams['Offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($order !== null) {
            $queryParams['Order'] = ObjectSerializer::toQueryValue($order, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdActionUrlPost
     *
     * Retrieves an URL to redirect the user to the first pending action of the document.
     *
     * @param  string $id Document Id (required)
     * @param  \Lacuna\Signer\Model\DocumentsActionUrlRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\DocumentsActionUrlResponse
     */
    public function apiDocumentsIdActionUrlPost($id, $body = null)
    {
        list($response) = $this->apiDocumentsIdActionUrlPostWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiDocumentsIdActionUrlPostWithHttpInfo
     *
     * Retrieves an URL to redirect the user to the first pending action of the document.
     *
     * @param  string $id Document Id (required)
     * @param  \Lacuna\Signer\Model\DocumentsActionUrlRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\DocumentsActionUrlResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdActionUrlPostWithHttpInfo($id, $body = null)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsActionUrlResponse';
        $request = $this->apiDocumentsIdActionUrlPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\DocumentsActionUrlResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdActionUrlPostAsync
     *
     * Retrieves an URL to redirect the user to the first pending action of the document.
     *
     * @param  string $id Document Id (required)
     * @param  \Lacuna\Signer\Model\DocumentsActionUrlRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdActionUrlPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdActionUrlPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdActionUrlPostAsyncWithHttpInfo
     *
     * Retrieves an URL to redirect the user to the first pending action of the document.
     *
     * @param  string $id Document Id (required)
     * @param  \Lacuna\Signer\Model\DocumentsActionUrlRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdActionUrlPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsActionUrlResponse';
        $request = $this->apiDocumentsIdActionUrlPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdActionUrlPost'
     *
     * @param  string $id Document Id (required)
     * @param  \Lacuna\Signer\Model\DocumentsActionUrlRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdActionUrlPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdActionUrlPost'
            );
        }

        $resourcePath = '/api/documents/{id}/action-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdCancellationPost
     *
     * Cancels the document by providing a reason for the cancellation.
     *
     * @param  string $id id (required)
     * @param  \Lacuna\Signer\Model\DocumentsCancelDocumentRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdCancellationPost($id, $body = null)
    {
        $this->apiDocumentsIdCancellationPostWithHttpInfo($id, $body);
    }

    /**
     * Operation apiDocumentsIdCancellationPostWithHttpInfo
     *
     * Cancels the document by providing a reason for the cancellation.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsCancelDocumentRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdCancellationPostWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdCancellationPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdCancellationPostAsync
     *
     * Cancels the document by providing a reason for the cancellation.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsCancelDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdCancellationPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdCancellationPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdCancellationPostAsyncWithHttpInfo
     *
     * Cancels the document by providing a reason for the cancellation.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsCancelDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdCancellationPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdCancellationPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdCancellationPost'
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsCancelDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdCancellationPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdCancellationPost'
            );
        }

        $resourcePath = '/api/documents/{id}/cancellation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdContentB64Get
     *
     * Downloads a specific version type of the document encoding the bytes in Base 64 format.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\DocumentsDocumentContentModel
     */
    public function apiDocumentsIdContentB64Get($id, $type = null)
    {
        list($response) = $this->apiDocumentsIdContentB64GetWithHttpInfo($id, $type);
        return $response;
    }

    /**
     * Operation apiDocumentsIdContentB64GetWithHttpInfo
     *
     * Downloads a specific version type of the document encoding the bytes in Base 64 format.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\DocumentsDocumentContentModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdContentB64GetWithHttpInfo($id, $type = null)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentContentModel';
        $request = $this->apiDocumentsIdContentB64GetRequest($id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\DocumentsDocumentContentModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdContentB64GetAsync
     *
     * Downloads a specific version type of the document encoding the bytes in Base 64 format.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdContentB64GetAsync($id, $type = null)
    {
        return $this->apiDocumentsIdContentB64GetAsyncWithHttpInfo($id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdContentB64GetAsyncWithHttpInfo
     *
     * Downloads a specific version type of the document encoding the bytes in Base 64 format.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdContentB64GetAsyncWithHttpInfo($id, $type = null)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentContentModel';
        $request = $this->apiDocumentsIdContentB64GetRequest($id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdContentB64Get'
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdContentB64GetRequest($id, $type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdContentB64Get'
            );
        }

        $resourcePath = '/api/documents/{id}/content-b64';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdContentGet
     *
     * Downloads a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdContentGet($id, $type = null)
    {
        $this->apiDocumentsIdContentGetWithHttpInfo($id, $type);
    }

    /**
     * Operation apiDocumentsIdContentGetWithHttpInfo
     *
     * Downloads a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdContentGetWithHttpInfo($id, $type = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdContentGetRequest($id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdContentGetAsync
     *
     * Downloads a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdContentGetAsync($id, $type = null)
    {
        return $this->apiDocumentsIdContentGetAsyncWithHttpInfo($id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdContentGetAsyncWithHttpInfo
     *
     * Downloads a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdContentGetAsyncWithHttpInfo($id, $type = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdContentGetRequest($id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdContentGet'
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentDownloadTypes $type The version type to download (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdContentGetRequest($id, $type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdContentGet'
            );
        }

        $resourcePath = '/api/documents/{id}/content';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdDelete
     *
     * Deletes a specific document using it's id.
     *
     * @param  string $id Document id (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdDelete($id)
    {
        $this->apiDocumentsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation apiDocumentsIdDeleteWithHttpInfo
     *
     * Deletes a specific document using it's id.
     *
     * @param  string $id Document id (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdDeleteAsync
     *
     * Deletes a specific document using it's id.
     *
     * @param  string $id Document id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdDeleteAsync($id)
    {
        return $this->apiDocumentsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdDeleteAsyncWithHttpInfo
     *
     * Deletes a specific document using it's id.
     *
     * @param  string $id Document id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdDelete'
     *
     * @param  string $id Document id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdDelete'
            );
        }

        $resourcePath = '/api/documents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdEnvelopeVersionsPost
     *
     * Adds a new version for an envelope.
     *
     * @param  string $id id (required)
     * @param  \Lacuna\Signer\Model\DocumentsEnvelopeAddVersionRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdEnvelopeVersionsPost($id, $body = null)
    {
        $this->apiDocumentsIdEnvelopeVersionsPostWithHttpInfo($id, $body);
    }

    /**
     * Operation apiDocumentsIdEnvelopeVersionsPostWithHttpInfo
     *
     * Adds a new version for an envelope.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsEnvelopeAddVersionRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdEnvelopeVersionsPostWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdEnvelopeVersionsPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdEnvelopeVersionsPostAsync
     *
     * Adds a new version for an envelope.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsEnvelopeAddVersionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdEnvelopeVersionsPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdEnvelopeVersionsPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdEnvelopeVersionsPostAsyncWithHttpInfo
     *
     * Adds a new version for an envelope.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsEnvelopeAddVersionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdEnvelopeVersionsPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdEnvelopeVersionsPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdEnvelopeVersionsPost'
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsEnvelopeAddVersionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdEnvelopeVersionsPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdEnvelopeVersionsPost'
            );
        }

        $resourcePath = '/api/documents/{id}/envelope/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdFlowPost
     *
     * Updates the document's flow.
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentFlowEditRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\FlowActionsDocumentFlowEditResponse
     */
    public function apiDocumentsIdFlowPost($id, $body = null)
    {
        list($response) = $this->apiDocumentsIdFlowPostWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiDocumentsIdFlowPostWithHttpInfo
     *
     * Updates the document's flow.
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentFlowEditRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\FlowActionsDocumentFlowEditResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdFlowPostWithHttpInfo($id, $body = null)
    {
        $returnType = '\Lacuna\Signer\Model\FlowActionsDocumentFlowEditResponse';
        $request = $this->apiDocumentsIdFlowPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\FlowActionsDocumentFlowEditResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdFlowPostAsync
     *
     * Updates the document's flow.
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentFlowEditRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdFlowPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdFlowPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdFlowPostAsyncWithHttpInfo
     *
     * Updates the document's flow.
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentFlowEditRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdFlowPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Lacuna\Signer\Model\FlowActionsDocumentFlowEditResponse';
        $request = $this->apiDocumentsIdFlowPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdFlowPost'
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentFlowEditRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdFlowPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdFlowPost'
            );
        }

        $resourcePath = '/api/documents/{id}/flow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdFolderPost
     *
     * Moves a document to a folder.
     *
     * @param  string $id id (required)
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdFolderPost($id, $body = null)
    {
        $this->apiDocumentsIdFolderPostWithHttpInfo($id, $body);
    }

    /**
     * Operation apiDocumentsIdFolderPostWithHttpInfo
     *
     * Moves a document to a folder.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdFolderPostWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdFolderPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdFolderPostAsync
     *
     * Moves a document to a folder.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdFolderPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdFolderPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdFolderPostAsyncWithHttpInfo
     *
     * Moves a document to a folder.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdFolderPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdFolderPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdFolderPost'
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsMoveDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdFolderPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdFolderPost'
            );
        }

        $resourcePath = '/api/documents/{id}/folder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdGet
     *
     * Retrieves the document's details.
     *
     * @param  string $id Document id (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\DocumentsDocumentModel
     */
    public function apiDocumentsIdGet($id)
    {
        list($response) = $this->apiDocumentsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation apiDocumentsIdGetWithHttpInfo
     *
     * Retrieves the document's details.
     *
     * @param  string $id Document id (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\DocumentsDocumentModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdGetWithHttpInfo($id)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentModel';
        $request = $this->apiDocumentsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\DocumentsDocumentModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdGetAsync
     *
     * Retrieves the document's details.
     *
     * @param  string $id Document id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdGetAsync($id)
    {
        return $this->apiDocumentsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdGetAsyncWithHttpInfo
     *
     * Retrieves the document's details.
     *
     * @param  string $id Document id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentModel';
        $request = $this->apiDocumentsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdGet'
     *
     * @param  string $id Document id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdGet'
            );
        }

        $resourcePath = '/api/documents/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdNotifiedEmailsPut
     *
     * Updates the document's notified emails
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentNotifiedEmailsEditRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdNotifiedEmailsPut($id, $body = null)
    {
        $this->apiDocumentsIdNotifiedEmailsPutWithHttpInfo($id, $body);
    }

    /**
     * Operation apiDocumentsIdNotifiedEmailsPutWithHttpInfo
     *
     * Updates the document's notified emails
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentNotifiedEmailsEditRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdNotifiedEmailsPutWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdNotifiedEmailsPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdNotifiedEmailsPutAsync
     *
     * Updates the document's notified emails
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentNotifiedEmailsEditRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdNotifiedEmailsPutAsync($id, $body = null)
    {
        return $this->apiDocumentsIdNotifiedEmailsPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdNotifiedEmailsPutAsyncWithHttpInfo
     *
     * Updates the document's notified emails
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentNotifiedEmailsEditRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdNotifiedEmailsPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdNotifiedEmailsPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdNotifiedEmailsPut'
     *
     * @param  string $id Id of the document (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentNotifiedEmailsEditRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdNotifiedEmailsPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdNotifiedEmailsPut'
            );
        }

        $resourcePath = '/api/documents/{id}/notified-emails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdRefusalPost
     *
     * Refuses a document by providing a reason for the refusal.
     *
     * @param  string $id id (required)
     * @param  \Lacuna\Signer\Model\RefusalRefusalRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdRefusalPost($id, $body = null)
    {
        $this->apiDocumentsIdRefusalPostWithHttpInfo($id, $body);
    }

    /**
     * Operation apiDocumentsIdRefusalPostWithHttpInfo
     *
     * Refuses a document by providing a reason for the refusal.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\RefusalRefusalRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdRefusalPostWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdRefusalPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdRefusalPostAsync
     *
     * Refuses a document by providing a reason for the refusal.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\RefusalRefusalRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdRefusalPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdRefusalPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdRefusalPostAsyncWithHttpInfo
     *
     * Refuses a document by providing a reason for the refusal.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\RefusalRefusalRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdRefusalPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdRefusalPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdRefusalPost'
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\RefusalRefusalRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdRefusalPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdRefusalPost'
            );
        }

        $resourcePath = '/api/documents/{id}/refusal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdSignaturesDetailsGet
     *
     * Retrieves the details of the document's signatures.
     *
     * @param  string $id The Id of the document (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel
     */
    public function apiDocumentsIdSignaturesDetailsGet($id)
    {
        list($response) = $this->apiDocumentsIdSignaturesDetailsGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation apiDocumentsIdSignaturesDetailsGetWithHttpInfo
     *
     * Retrieves the details of the document's signatures.
     *
     * @param  string $id The Id of the document (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdSignaturesDetailsGetWithHttpInfo($id)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel';
        $request = $this->apiDocumentsIdSignaturesDetailsGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdSignaturesDetailsGetAsync
     *
     * Retrieves the details of the document's signatures.
     *
     * @param  string $id The Id of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdSignaturesDetailsGetAsync($id)
    {
        return $this->apiDocumentsIdSignaturesDetailsGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdSignaturesDetailsGetAsyncWithHttpInfo
     *
     * Retrieves the details of the document's signatures.
     *
     * @param  string $id The Id of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdSignaturesDetailsGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel';
        $request = $this->apiDocumentsIdSignaturesDetailsGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdSignaturesDetailsGet'
     *
     * @param  string $id The Id of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdSignaturesDetailsGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdSignaturesDetailsGet'
            );
        }

        $resourcePath = '/api/documents/{id}/signatures-details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdTicketGet
     *
     * Generates a URL (ticket) to download a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentTicketType $type The version type to download (optional)
     * @param  bool $preview If true, when downloading the document, the response will not include the name of the file (useful when embedding the document inside a web page for previewing) (optional, default to false)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\TicketModel
     */
    public function apiDocumentsIdTicketGet($id, $type = null, $preview = 'false')
    {
        list($response) = $this->apiDocumentsIdTicketGetWithHttpInfo($id, $type, $preview);
        return $response;
    }

    /**
     * Operation apiDocumentsIdTicketGetWithHttpInfo
     *
     * Generates a URL (ticket) to download a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentTicketType $type The version type to download (optional)
     * @param  bool $preview If true, when downloading the document, the response will not include the name of the file (useful when embedding the document inside a web page for previewing) (optional, default to false)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\TicketModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdTicketGetWithHttpInfo($id, $type = null, $preview = 'false')
    {
        $returnType = '\Lacuna\Signer\Model\TicketModel';
        $request = $this->apiDocumentsIdTicketGetRequest($id, $type, $preview);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\TicketModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdTicketGetAsync
     *
     * Generates a URL (ticket) to download a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentTicketType $type The version type to download (optional)
     * @param  bool $preview If true, when downloading the document, the response will not include the name of the file (useful when embedding the document inside a web page for previewing) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdTicketGetAsync($id, $type = null, $preview = 'false')
    {
        return $this->apiDocumentsIdTicketGetAsyncWithHttpInfo($id, $type, $preview)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdTicketGetAsyncWithHttpInfo
     *
     * Generates a URL (ticket) to download a specific version type of the document.
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentTicketType $type The version type to download (optional)
     * @param  bool $preview If true, when downloading the document, the response will not include the name of the file (useful when embedding the document inside a web page for previewing) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdTicketGetAsyncWithHttpInfo($id, $type = null, $preview = 'false')
    {
        $returnType = '\Lacuna\Signer\Model\TicketModel';
        $request = $this->apiDocumentsIdTicketGetRequest($id, $type, $preview);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdTicketGet'
     *
     * @param  string $id Document id (required)
     * @param  \Lacuna\Signer\Model\DocumentTicketType $type The version type to download (optional)
     * @param  bool $preview If true, when downloading the document, the response will not include the name of the file (useful when embedding the document inside a web page for previewing) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdTicketGetRequest($id, $type = null, $preview = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdTicketGet'
            );
        }

        $resourcePath = '/api/documents/{id}/ticket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($preview !== null) {
            $queryParams['preview'] = ObjectSerializer::toQueryValue($preview, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsIdVersionsPost
     *
     * Adds a new version for the document.
     *
     * @param  string $id id (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentAddVersionRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiDocumentsIdVersionsPost($id, $body = null)
    {
        $this->apiDocumentsIdVersionsPostWithHttpInfo($id, $body);
    }

    /**
     * Operation apiDocumentsIdVersionsPostWithHttpInfo
     *
     * Adds a new version for the document.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentAddVersionRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsIdVersionsPostWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdVersionsPostRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsIdVersionsPostAsync
     *
     * Adds a new version for the document.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentAddVersionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdVersionsPostAsync($id, $body = null)
    {
        return $this->apiDocumentsIdVersionsPostAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsIdVersionsPostAsyncWithHttpInfo
     *
     * Adds a new version for the document.
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentAddVersionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsIdVersionsPostAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->apiDocumentsIdVersionsPostRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsIdVersionsPost'
     *
     * @param  string $id (required)
     * @param  \Lacuna\Signer\Model\DocumentsDocumentAddVersionRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsIdVersionsPostRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiDocumentsIdVersionsPost'
            );
        }

        $resourcePath = '/api/documents/{id}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsKeysKeySignaturesGet
     *
     * Validates each signature in a document using the verification code
     *
     * @param  string $key The verification code presented in the document (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel
     */
    public function apiDocumentsKeysKeySignaturesGet($key)
    {
        list($response) = $this->apiDocumentsKeysKeySignaturesGetWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation apiDocumentsKeysKeySignaturesGetWithHttpInfo
     *
     * Validates each signature in a document using the verification code
     *
     * @param  string $key The verification code presented in the document (required)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsKeysKeySignaturesGetWithHttpInfo($key)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel';
        $request = $this->apiDocumentsKeysKeySignaturesGetRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsKeysKeySignaturesGetAsync
     *
     * Validates each signature in a document using the verification code
     *
     * @param  string $key The verification code presented in the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsKeysKeySignaturesGetAsync($key)
    {
        return $this->apiDocumentsKeysKeySignaturesGetAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsKeysKeySignaturesGetAsyncWithHttpInfo
     *
     * Validates each signature in a document using the verification code
     *
     * @param  string $key The verification code presented in the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsKeysKeySignaturesGetAsyncWithHttpInfo($key)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsDocumentSignaturesInfoModel';
        $request = $this->apiDocumentsKeysKeySignaturesGetRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsKeysKeySignaturesGet'
     *
     * @param  string $key The verification code presented in the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsKeysKeySignaturesGetRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling apiDocumentsKeysKeySignaturesGet'
            );
        }

        $resourcePath = '/api/documents/keys/{key}/signatures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsPost
     *
     * Creates one or multiple documents.
     *
     * @param  \Lacuna\Signer\Model\DocumentsCreateDocumentRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\DocumentsCreateDocumentResult[]
     */
    public function apiDocumentsPost($body = null)
    {
        list($response) = $this->apiDocumentsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiDocumentsPostWithHttpInfo
     *
     * Creates one or multiple documents.
     *
     * @param  \Lacuna\Signer\Model\DocumentsCreateDocumentRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\DocumentsCreateDocumentResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsPostWithHttpInfo($body = null)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsCreateDocumentResult[]';
        $request = $this->apiDocumentsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\DocumentsCreateDocumentResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsPostAsync
     *
     * Creates one or multiple documents.
     *
     * @param  \Lacuna\Signer\Model\DocumentsCreateDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsPostAsync($body = null)
    {
        return $this->apiDocumentsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsPostAsyncWithHttpInfo
     *
     * Creates one or multiple documents.
     *
     * @param  \Lacuna\Signer\Model\DocumentsCreateDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Lacuna\Signer\Model\DocumentsCreateDocumentResult[]';
        $request = $this->apiDocumentsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsPost'
     *
     * @param  \Lacuna\Signer\Model\DocumentsCreateDocumentRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsPostRequest($body = null)
    {

        $resourcePath = '/api/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiDocumentsValidateSignaturesPost
     *
     * Validates each signature in the uploaded document
     *
     * @param  \Lacuna\Signer\Model\SignatureSignaturesInfoRequest $body body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Lacuna\Signer\Model\SignerModel[]
     */
    public function apiDocumentsValidateSignaturesPost($body = null)
    {
        list($response) = $this->apiDocumentsValidateSignaturesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiDocumentsValidateSignaturesPostWithHttpInfo
     *
     * Validates each signature in the uploaded document
     *
     * @param  \Lacuna\Signer\Model\SignatureSignaturesInfoRequest $body (optional)
     *
     * @throws \Lacuna\Signer\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Lacuna\Signer\Model\SignerModel[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiDocumentsValidateSignaturesPostWithHttpInfo($body = null)
    {
        $returnType = '\Lacuna\Signer\Model\SignerModel[]';
        $request = $this->apiDocumentsValidateSignaturesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\SignerModel[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Lacuna\Signer\Model\ErrorModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiDocumentsValidateSignaturesPostAsync
     *
     * Validates each signature in the uploaded document
     *
     * @param  \Lacuna\Signer\Model\SignatureSignaturesInfoRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsValidateSignaturesPostAsync($body = null)
    {
        return $this->apiDocumentsValidateSignaturesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiDocumentsValidateSignaturesPostAsyncWithHttpInfo
     *
     * Validates each signature in the uploaded document
     *
     * @param  \Lacuna\Signer\Model\SignatureSignaturesInfoRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiDocumentsValidateSignaturesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Lacuna\Signer\Model\SignerModel[]';
        $request = $this->apiDocumentsValidateSignaturesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiDocumentsValidateSignaturesPost'
     *
     * @param  \Lacuna\Signer\Model\SignatureSignaturesInfoRequest $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiDocumentsValidateSignaturesPostRequest($body = null)
    {

        $resourcePath = '/api/documents/validate-signatures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
